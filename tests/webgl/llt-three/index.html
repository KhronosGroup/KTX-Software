<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>msc_transcoder_test with three.js</title>
  </head>
  <script src="../msc_basis_transcoder.js"></script>
  <script defer src="https://unpkg.com/es-module-shims@0.4.6/dist/es-module-shims.js"></script>
  <!-- Use an import map shim to ensure KTX2Loader and the demo itself
       use the same CDN-hosted copy of the threejs library. -->
  <script type="importmap-shim">
  {
    "imports": {
      "https://raw.githack.com/donmccurdy/three.js/feat-ktx2loader/build/three.module.js": "https://unpkg.com/three@0.113.2/build/three.module.js"
    }
  }
  </script>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; }
    canvas { display:block; }
    h2 { margin-top: 0; }
    #panel {
      position: absolute;
      color: white;
      background-color:rgba(0.3, 0.3, 0.3, 0.3);
      padding: 0.5em;
      left: 50%;
      transform: translate(-50%, 0);
      max-width: 50em;
    }
  </style>
  <div id="panel">
    <h2>msc_basis_transcoder test</h2>
    <p>
      Loads and parses a KTX2 file with a plain JS loader, transcodes the
      Basis Universal-compressed payload with <code>msc_basis_transcoder</code>,
      and renders the result with three.js. This texture has been transcoded
      to <b id='format'>FORMAT</b>.
    </p>
    <div id="log"></div>
  </div>
  <script type="module-shim">
    import * as THREE from 'https://unpkg.com/three@0.113.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.113.2/examples/jsm/controls/OrbitControls.js';
    import { KTX2Loader } from 'https://raw.githack.com/donmccurdy/three.js/feat-ktx2loader/examples/jsm/loaders/KTX2Loader.js';

    const width = window.innerWidth;
    const height = window.innerHeight;

    const renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( width, height );
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild( renderer.domElement );

    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xF0F0F0 );

    const camera = new THREE.PerspectiveCamera( 60, width / height, 0.1, 100 );
    camera.position.set( 2, 1.5, 1 );
    camera.lookAt( scene.position );
    scene.add(camera);

    const controls = new OrbitControls( camera, renderer.domElement );
    controls.autoRotate = true;

    // PlaneBufferGeometry UVs assume flipY=true, which compressed textures don't support.
    const geometry = flipY( new THREE.PlaneBufferGeometry() );
    const material = new THREE.MeshBasicMaterial( {
      color: 0xFFFFFF,
      side: THREE.DoubleSide
    } );
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    const formats = [
      'RGBA_ASTC_4x4_Format',
      'RGB_S3TC_DXT1_Format',
      'RGBA_S3TC_DXT5_Format',
      'RGB_PVRTC_4BPPV1_Format',
      'RGBA_PVRTC_4BPPV1_Format',
      'RGB_ETC1_Format',
      'RGB_ETC2_Format',
      'RGBA_ETC2_EAC_Format',
    ];

    const formatToString = ( format ) => formats.find( ( name ) => THREE[ name ] === format );

    animate();

    new KTX2Loader()
      .detectSupport( renderer )
      .load( '../libktx-webgl/ktx_app_basis.ktx2', ( texture ) => {

        material.map = texture;
        elem('format').innerText = formatToString( material.map.format );

        material.needsUpdate = true;

      }, ( p ) => console.log( `...${p}` ), ( e ) => console.error( e ) );

    function elem(id) {
      return document.getElementById(id);
    }

    function animate() {

      requestAnimationFrame( animate );

      controls.update();

      renderer.render( scene, camera );

    }

    window.addEventListener( 'resize', () => {

      const width = window.innerWidth;
      const height = window.innerHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize( width, height );

    }, false );

    /** Correct UVs to be compatible with `flipY=false` textures. */
    function flipY ( geometry ) {

      var uv = geometry.attributes.uv;

      for ( var i = 0; i < uv.count; i ++ ) {

        uv.setY( i, 1 - uv.getY( i ) );

      }

      return geometry;

    }
  </script>
</html>
